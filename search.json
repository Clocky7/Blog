[{"title":"关于第一次接触博客","url":"/post/6c390488/","content":"\n\n\n&emsp;&emsp;怎么说呢，我身边有很多人很早就踏入了外网、博客的圈子里，有的甚至在初中就有了自己日常更新的习惯。他们都是很厉害的人，而我只是个刚刚观测到冰山一角的萌新。代码、技术、生活，blog就是记录这些事情的存在，但我不是天才。对代码生疏，对技术不熟悉，只怀着一颗希望探索未知的心……\n&emsp;&emsp;自此，一条充满神秘与乐趣的路已经摆在我的身前。生活，新发现，新思路都会在这里的blog中记录，我热爱生活、憧憬未来，我会坚持下去。希望能在未来的某天成为一束光，照进身边每个人的世界————\n学习博客的原因\n&emsp;&emsp;本人是一名资深Arknights玩家，近期偶然得知出现了Arknights的blog主题，在朋友的帮助下从github上学习并搭建了自己的博客。身为计算机学院的学生，却对外网与代码了解甚少，着实是一个槽点。见多了形形色色有个性的博客，也想试试搭建属于自己的东西，也想在写博客的过程中见识到更多有意思的事。\n自己搭建时遇到的问题&emsp;&emsp;当我们所编辑的MD文件中所粘贴的图片有两种类型，一种是本地图片，另一种是在线图片，如果我们需要将我们所编辑的文本上传到博客时，本地图片会出现丢失，只出现本地格式路径。&emsp;&emsp;建议：&emsp;&emsp;外链图片转存失败,源站可能有防盗链机制,建议将图片保存至本地直接上传\n自言自语$ 其实忘了没啥想说的~~~","categories":["日常"],"tags":["有感而发"]},{"title":"python函数基础与变量作用域","url":"/post/78fbc401/","content":"一.函数基础知识\n函数是面向过程编程的最小单位，也是一种数据  \n目的就是封装方便以后复用  \n函数分自定义函数，内置函数（python官方），第三方函数（第三方库）\n\n# 使用def 语句定义一个函数adef function_name(parameters):    # 函数体    # 进行一些操作    return result  # 可选的返回值 print(type(function_name))\n\n&lt;class &#39;function&#39;&gt;\n\n\ndef：用于声明一个函数，告诉 Python 这是一个函数的定义。\n\nfunction_name：函数名，一个有效的标识符，规则和变量名一致。\n\nparameters：形参，可以是0 ~ n 个，参数之间用逗号分隔。\n\n函数体：定义函数执行的具体操作。\n\nreturn：指定函数的返回值，没有则默认返回None。\n\nreturn之后的代码不会执行。\n\n\n# 示例def test():    print(&#x27;test&#x27;)    return 1    print(&#x27;test2&#x27;)    return    print(&#x27;test3&#x27;)    return # 直接调用，最后显示的1是因为ipynb文件会直接渲染最后一个值，而.py文件就不会test() # 比如这里，x是最后一个值，所以会直接渲染，没有渲染上面的1x = 10x\n\ntest\n10\n\ndef test():    print(&#x27;test&#x27;)    return 1    print(&#x27;test2&#x27;)    return    print(&#x27;test3&#x27;)    return test()# 先执行return后面的语句，再执行return后面的语句，x实际为1x = test()print(x)\n\ntest\ntest\n1\n\n二.函数调用\n函数调用是一个表达式，可以参与运算\n\n2.1 位置传参# 指形参与实参会互相匹配顺序数量，参数（argument）def func(a,b):    print(a,b)    return func(1,2)func(2,1)func(1,2,3)\n\n1 2\n2 1\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[21], line 8\n    6 func(1,2)\n    7 func(2,1)\n----&gt; 8 func(1,2,3)\n\nTypeError: func() takes 2 positional arguments but 3 were given\n\n# 只要匹配的上，用不用参数无所谓def func(a,b):    print(a)func(1,2)\n\n1\n\n2.2 关键词传参# 直接指定特定参数传什么数据，没有顺序问题def func(a,b,c):    print(a,b,c)func(b = 1,c = 2,a = 3) # 只传几个，关键词传参必须放在所有位置参数后面def func(a,b,c):    print(a,b,c)func(1,c = 2,b = 3 )\n\n3 1 2\n1 3 2\n\ndef func(a,b,c):    print(a,b,c)func(1,c = 3,2)\n\nCell In[36], line 3\n    func(1,c = 3,2)\n                ^\nSyntaxError: positional argument follows keyword argument\n\n2.3 参数默认值# 直接在构建函数时给形参赋值def test(a, b = 2 , c = 1):    print(a,b,c)    returntest(1)test(1,2,3)test(1,c = 3)test(1,None,3)\n\n1 2 1\n1 2 3\n1 2 3\n1 None 3\n\n# 注意，默认值参数必须放在形参后面，除非全有默认值def test(a = 1, b, c = 3):    print(a,b,c)    return\n\nCell In[46], line 2\n    def test(a = 1, b, c = 3):\n                    ^\nSyntaxError: parameter without a default follows parameter with a default\n\n2.4 可变位置参数# 在变量名前加上 * 可以将所有数据收集成一个元组，不传都行，是空元组def test(*args):    print(args)    print(type(args))    print()    return test(1,2,3)test() # 也可以先传普通形参def test(a,*args):    print(a)    print(args)    print(type(args))    returntest(1,2)\n\n(1, 2, 3)\n&lt;class &#39;tuple&#39;&gt;\n\n()\n&lt;class &#39;tuple&#39;&gt;\n\n1\n(2,)\n&lt;class &#39;tuple&#39;&gt;\n\n2.5 可变关键词参数（字典）# 在变量名前加 ** ，可以将后面传入的参数以字典的形式传入,且必须以关键词传参def test(a,**kwargs):    print(kwargs)    print(type(kwargs))    for i in kwargs:        print(i,kwargs[i]) test(1,b=2,c=3)\n\n&#123;&#39;b&#39;: 2, &#39;c&#39;: 3&#125;\n&lt;class &#39;dict&#39;&gt;\nb 2\nc 3\n\n\n两个可变参数的联合使用  \n实质是剩余参数传递，即普通形参传完后剩余的参数传递给可变参数\n\ndef test(a,*args,**kwargs):    print(a)    print(args)    print(kwargs) test(1,2,3,4,Name = &#x27;clocky7&#x27;)\n\n1\n(2, 3, 4)\n&#123;&#39;Name&#39;: &#39;clocky7&#39;&#125;\n\n2.6 多参数解包2.6.1 解包位置传参#就是反过来在实参中使用*def test(a,b,c):    print(a,b,c) x = (1,2,3)test(*x)\n\n1 2 3\n\n# 实参多于形参def test(a,b,c):    print(a,b,c) x = (1,2,3,4)test(*x)\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[68], line 6\n    3     print(a,b,c)\n    5 x = (1,2,3,4)\n----&gt; 6 test(*x)\n\nTypeError: test() takes 3 positional arguments but 4 were given\n\n# 实参少于形参def test(a,b,c):    print(a,b,c)x = (1,2)test(*x)\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[70], line 5\n    3     print(a,b,c)\n    4 x = (1,2)\n----&gt; 5 test(*x)\n\nTypeError: test() missing 1 required positional argument: &#39;c&#39;\n\n2.6.2 解包关键字传参（字典）def test(a,b,c):    print(a,b,c)x = &#123;&#x27;a&#x27;:1,&#x27;c&#x27;:3,&#x27;b&#x27;:2&#125;test(**x)\n\n1 2 3\n\n注意 ： * 本身不是参数，只是一个占位符\ndef test(a,*,b = 3):    print(a,b)test(1)\n\n1 3\n\ndef test(a,*,b = 3):    print(a,b)test(1,3)\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[83], line 3\n    1 def test(a,*,b = 3):\n    2     print(a,b)\n----&gt; 3 test(1,3)\n\nTypeError: test() takes 1 positional argument but 2 were given\n\n# 意思是*占一个参数位置，其后面的参数若要传参必须以关键字传参def test(a,*,b = 3):    print(a,b)test(1,b = 4)\n\n1 4\n\n三.可变与不可变参数实质上是传入变量中的数据,但指向一个对象。\n# 传不可变数据def test(a): #这里其实本质是传入10，但x作为一个变量兼对象，所以其实是传入了地址引用    a = 20 x = 10test(x)print(x)  # 传可变数据def test(a):    a[0] = 20 y = [1,2,3]test(y)print(y)\n\n10\n[20, 2, 3]\n\n# 不可变的元组也一样def test(a):    a[0] = 20z = (1,2,3)test(z)print(z)\n\n---------------------------------------------------------------------------\nTypeError                                 Traceback (most recent call last)\nCell In[92], line 5\n    3     a[0] = 20\n    4 z = (1,2,3)\n----&gt; 5 test(z)\n    6 print(z)\n\nCell In[92], line 3, in test(a)\n    2 def test(a):\n----&gt; 3     a[0] = 20\n\nTypeError: &#39;tuple&#39; object does not support item assignment\n\n四.匿名函数没有名字，可以有任意数量的参数，但只能包含一个表达式，并返回该表达式的结果。用lambda定义匿名函数。\n\nlambda arguments: expression\n\nfn = lambda x:x+1print(fn(1)) # 用于条件表达式,判断是否为偶数is_even = lambda x: &quot;Even&quot; if x % 2 == 0 else &quot;Odd&quot; print(is_even(4))  # 输出: Evenprint(is_even(7))  # 输出: Odd\n\n2\nEven\nOdd\n\n五.内置函数# all函数 可迭代对象中的所有元素都为 `True`，返回 `True`，否则返回 `False`print(all([True, True, False]))  # 输出: Falseprint(all([1, 2, 3]))           # 输出: True print() # any函数 可迭代对象中只要一个元素为 `True`，返回 `True`，否则返回 `False`print(any([False, False, False]))  # 输出: Falseprint(any([1, 2, 3]))             # 输出: True\n\nFalse\nTrue\n\nFalse\nTrue\n\n# sum函数，返回可迭代对象中所有元素的总和print(sum([1,2,3,4,5]))\n\n15\n\n# sorted 返回一个新列表，其中包含可迭代对象中的元素，按照升序排序（这就是默认排序）l = (1, 5, 3, 2, 4)print(sorted(l)) # sorted() 函数还可以接受一个 key 参数，指定一个函数，用这个函数操作的结果来排序（排序的内容仍然是原可迭代对象中的元素）l = (1, 5, 3, 2, 4)def my_key(x):    return x % 3print(sorted(l, key=my_key))\n\n[1, 2, 3, 4, 5]\n[3, 1, 4, 5, 2]\n\n这里补充一个小知识：经典的math库中abs()表示取绝对值\n# reversed() 返回一个反向迭代器x = reversed([1, 2, 3]) # 将方向迭代器转换为列表re = list(x) print(x,type(x))print(re)\n\n&lt;list_reverseiterator object at 0x0000019B8496A530&gt; &lt;class &#39;list_reverseiterator&#39;&gt;\n[3, 2, 1]\n\n# callable 检查对象是否可以当函数被调用def fn(x):    return print(callable(fn))print(callable(print))print(callable(123))\n\nTrue\nTrue\nFalse\n\n# zip 将多个可迭代对象中对应元素打包成一个zip对象，常用于并行遍历多个序列，如果超出则丢弃a = [1, 2, 3]b = (&#x27;name&#x27;,&#x27;age&#x27;)c = (&#x27;clocky&#x27;,&#x27;20&#x27;) x = zip(a,b,c)print(x,type(x))print(list(x))\n\n&lt;zip object at 0x0000019B84F18880&gt; &lt;class &#39;zip&#39;&gt;\n[(1, &#39;name&#39;, &#39;clocky&#39;), (2, &#39;age&#39;, &#39;20&#39;)]\n\n# exec 执行存储在字符串中的 Python 代码（这个比eval能写的内容更多）# eval 只能执行一个字符串表达式，exec可以执行多行code = &#x27;&#x27;&#x27;for i in range(3):             print(i)&#x27;&#x27;&#x27; exec(code)\n\n0\n1\n2\n\n# globals 返回值为一个字典，字典key为当前python环境全局变量的名字 for key in globals():    print(key)\n\n__name__\n__doc__\n__package__\n__loader__\n__spec__\n__builtin__\n__builtins__\n........\n\n# locals 返回一个字典，字典key为当前函数内部或者局部的变量名def fn(x):    y = x + 1    print(locals()) fn(1)\n\n&#123;&#39;x&#39;: 1, &#39;y&#39;: 2&#125;\n\n# filter（fun,x） 返回一个经过函数筛选的可迭代对象filter,函数操作后实际会给出一个布尔值，若为True则原数据保留，否则丢弃# filter 又叫过滤器numbers = [1, 2, 3, 4, 5]filtered = filter(lambda x: x**2, numbers)print(filtered,type(filtered))print(list(filtered)) \n\n&lt;filter object at 0x000002A4449C1F60&gt; &lt;class &#39;filter&#39;&gt;\n[1, 2, 3, 4, 5]\n\n5.1 高阶函数5.1.1 map# 类似filter()函数，返回一个迭代器x = [1,2,3,4,5,6,7,8,9,10]def is_even(n):    if n % 2 == 0:        return n even_numbers = map(is_even, x)print(list(even_numbers))\n\n[None, 2, None, 4, None, 6, None, 8, None, 10]\n\n5.1.2 reduce# 这里不同的是用于两个参数的函数，reduce会将函数操作后的返回值作为第一个参数，再取下一个数据# reduce(fun,arg,init)会返回函数的最后一个返回值,其中init是初始值，可自定义，将其作为第一个参数，多用于累加后再加一个值from functools import reduce x = [1, 2, 3, 4, 5]def fn(a,b):    print(a,b)    return a+bre = reduce(fn,x,0) print()print(re)\n\n0 1\n1 2\n3 3\n6 4\n10 5\n\n15\n\n六.变量作用域\n指在程序中某个变量的有效范围，也就是在代码的哪个部分可以访问或修改该变量\n\nPython中的变量作用域遵循LEGB规则（Local, Enclosing, Global, Built-in），依次搜索变量的定义位置\n\n函数内部可以访问内部变量和外部的全局变量，外部则不能访问内部局部变量\n\n\n6.1 Local→局部作用域在函数调用时被创建，在函数调用后自动销毁。\n6.2 Enclosing→嵌套作用域\n指外层函数中的变量，在内层函数中可访问，但不可修改。\n\n当一个函数嵌套在另一个函数内部时，外层函数的变量属于Enclosing作用域\n\n内层函数变量若与外层变量同名，则优先选择内层\n\n实质上就是在最内层找到变量，若找不到，则继续往外层找，一层一层直到找到为止。\n\n\ndef fn1():    a = 100     def fn2():        a = 200        print(a)    fn2() fn1()\n\n200\n\n6.3 全局作用域\n指模块级别定义的变量，整个模块都可以访问。\n\n如果想在函数中修改全局变量，需要使用global关键字\n\n\n6.4 Built-in→内建作用域\n包含Python内建的函数、异常和常量，如print(), len(), int, Exception等。\n\n这些变量可以在任何地方使用。\n\n\n6.5 函数调用问题# 特殊调用a = [1,2,3,lambda x:x+1]a[3](1)\n\n2\n\n# 函数无论在哪里调用，一定是在它定义的作用域下运行a = 1 def fn():    print(a) def fn1():    a = 2    fn() fn1()\n\n1\n\n修改变量的值\n# 一个会报错的情况，x的赋值和print顺序不能换，换了甚至取不到外面的值x = 1def f1():    print(x)    x = 2 f1()\n\n---------------------------------------------------------------------------\nUnboundLocalError                         Traceback (most recent call last)\nCell In[31], line 7\n    4     print(x)\n    5     x = 2\n----&gt; 7 f1()\n\nCell In[31], line 4, in f1()\n    3 def f1():\n----&gt; 4     print(x)\n    5     x = 2\n\nUnboundLocalError: cannot access local variable &#39;x&#39; where it is not associated with a value\n\n# 修改全局变量a = 1def f1():        global a    print(a)    a = 2 f1()print(a)\n\n1\n2\n\n# 修改函数外层变量a = 1def foo():    a = 2     def foo1():        nonlocal a        print(a)        a = 3     foo1()    print(a) foo()print(a)\n\n2\n3\n1\n\n# 变量查找遵从由内向外，全局之后还有官方系统的内建作用域def f1():    def f2():        print(__name__)    f2()f1()\n\n__main__\n\n6.6 函数内层分配1.将函数代码存储到代码区，函数中代码不执行。\n2.调用函数时，在内存中开辟空间（栈帧），存储函数内部定义的变量。\n3.函数调用后，栈帧立即被释放。\n七.递归函数# 先将一个简单的,函数内部的作用域是可以访问定义的函数自身的,但是很容易陷入死循环（函数自调用）# 这种情况一般和条件语句混合使用，强行退出自调用a = 1def fn():    pass def fn1():    print(a)    print(fn())    print(fn1())fn1()\n\n1 None\n1 None\n1 None \n...\n1 None\n1 None\n\n---------------------------------------------------------------------------\nRecursionError                            Traceback (most recent call last)\nCell In[40], line 10\n    8     print(fn())\n    9     print(fn1())\n---&gt; 10 fn1()\n\nCell In[40], line 9, in fn1()\n    7 print(a)\n    8 print(fn())\n----&gt; 9 print(fn1())\n\nCell In[40], line 9, in fn1()\n    7 print(a)\n    8 print(fn())\n----&gt; 9 print(fn1())\n\n    [... skipping similar frames: fn1 at line 9 (2972 times)]\n\nCell In[40], line 9, in fn1()\n    7 print(a)\n    8 print(fn())\n----&gt; 9 print(fn1())\n\nCell In[40], line 7, in fn1()\n    6 def fn1():\n----&gt; 7     print(a)\n    8     print(fn())\n    9     print(fn1())\n\nFile c:\\Users\\Clocky7\\anaconda3\\envs\\start1\\Lib\\site-packages\\ipykernel\\iostream.py:664, in OutStream.write(self, string)\n    655 def write(self, string: str) -&gt; Optional[int]:  # type:ignore[override]\n    656     &quot;&quot;&quot;Write to current stream after encoding if necessary\n    657 \n    658     Returns\n(...)    662 \n    663     &quot;&quot;&quot;\n--&gt; 664     parent = self.parent_header\n    666     if not isinstance(string, str):\n    667         msg = f&quot;write() argument must be str, not &#123;type(string)&#125;&quot;  # type:ignore[unreachable]\n\nRecursionError: maximum recursion depth exceeded\n\n# 正确用法a = 1def fn(x):    if x &gt;= 5:        return 5    else:        return fn(x+1)    fn(a)\n\n5\n\n# 用于阶乘计算 def jiecheng(a):    if a &lt;= 1:        return 1    else:        return a * jiecheng(a - 1) print(jiecheng(5))\n\n120\n\n","categories":["培训"],"tags":["python基础"]},{"title":"python常见复合类型基础","url":"/post/c3da89ad/","content":"一.列表\n列表中可以填充各种类型的数据，且可以同时存在于一个列表中，包括可以包含几个列表。  \n\n列表中的数据有顺序、有下标。\n\n\n1.1 列表创建#创建空列表a = list()print(a) #创建列表b = list([1,2,3])print(b) #创建字符列表c = list(&#x27;abc&#x27;)print(c)    \n\n[]\n[1, 2, 3]\n[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]\n\n总结：只要可以取下标，就可以传入列表。\n1.2 列表运算\n与字符串基本相似，可以根据字符串运算参考。\n\n#列表合并a = [100,200,300]b = [400,500,600]c = a + bprint(c) #列表累乘（累乘必须乘以正整数,2.0这类也不可以）a = [1,2]b = a * 3print(b) #加等,即源式加后面的式子a = [1,2,3]a+=[4,5,6]print(a) #乘等，同理a = [1,2,3]a*=3print(a) #判断是否包含，同理于字符串a = [1,2,3,4,5,6]print(1 in a)\n\n[100, 200, 300, 400, 500, 600]\n[1, 2, 1, 2, 1, 2]\n[1, 2, 3, 4, 5, 6]\n[1, 2, 3, 1, 2, 3, 1, 2, 3]\nTrue\n\n1.3 列表基本访问#下标访问简单列表元素a = [1,2,3,4,5]print(a[0]) #切片访问列表元素（这里切片出来是一个列表，因为其本身就是一个列表）a = [1,2,3,4,5]print(a[1:3]) #多重列表a = [[1,2,3],     [4,5,6],     [7,8,9]] #取了第二个列表，然后取了其第一个元素print(a[1][0]) #取了前两个列表print(a[0:2]) #取了前两个列表，然后取了第一个列表print(a[0:2][0]) #取了前两个列表，然后取了第一个列表，然后取了第一个元素print(a[0:2][0][0])\n\n1\n[2, 3]\n4\n[[1, 2, 3], [4, 5, 6]]\n[1, 2, 3]\n1\n\n1.4 列表添加元素#增x = [1,2,3]x.append(4)print(x) #插入x = [1,2,3]x.insert(1,4)print(x) #增可迭代对象x = [1,2,3]x.extend([4,5,6])print(x)\n\n[1, 2, 3, 4]\n[1, 4, 2, 3]\n[1, 2, 3, 4, 5, 6\n\n扩展：id（）函数的运用其可以查看一个变量保存的数据地址.\n#列表append x = [1,2,3]print(id(x)) x.append(4)print(id(x)) #列表相加 a = [1,2,3]print(id(a)) b = [4,5,6]a = a + b print(id(a))\n\n2278015630464\n2278015630464\n2277993865920\n2278015819136\n\n&emsp;&emsp;\n1.5 修改元素#在列表下标范围内选元素修改 a = [1,2,3,4,5]a[3] = 100print(a) #切片赋值 #超出范围a = [1,2,3,4,5]a[4:100] = [1,2]print(a) a = [1,2,3,4,5]a[1:3] = [100,200]print(a)\n\n[1, 2, 3, 100, 5]\n[1, 2, 3, 4, 1, 2]\n[1, 100, 200, 4, 5]\n\n总结：若只修改一个元素，必须在列表序列范围内。若用切片修改数据，可以超出范围，但必须是可迭代对象且符合条件。\n1.6 删除方法\nremove是直接删除列表内所含元素值，  \npop是删除列表内指定位置的元素，  \nclear是清空列表\n\n#remove方法a = [1,2,3,4,5,6,7,8,9,10]a.remove(1)print(a) #pop方法a = [1,2,3,4,5,6,7,8,9,10]a.pop(0)print(a) #clear方法a = [1,2,3,4,5,6,7,8,9,10]a.clear()print(a) #后期方法dela = [1,2,3,4,5,6,7,8,9,10]del a[0]print(a) #直接删除变量del aprint(a)\n\n[2, 3, 4, 5, 6, 7, 8, 9, 10]\n[2, 3, 4, 5, 6, 7, 8, 9, 10]\n[]\n[2, 3, 4, 5, 6, 7, 8, 9, 10]\n\nNameError: name &#39;a&#39; is not defined\n\n1.7 列表常见API#len（）a = [1,2,3,4,5]print(len(a)) #max（）a = [1,2,3,4,5]print(max(a)) #min（）a = [1,2,3,4,5]print(min(a)) #list（sep）,转元组为列表a = (1,2,3,4,5)print(list(a))\n\n5\n5\n1\n[1, 2, 3, 4, 5]\n\n扩展API\n#index()索引一个元素的第一个下标a = [1,2,3,4,5]print(a.index(3))\n\n2\n\n二.元组2.1 元组基本属性\n元组中的元素一般不可变动，较列表不同。\n\n#空元组x = ()print(x) #元组切片x = (1,2,3,4)print(x[1:7]) #单个数据的元组x = (1,)  print(x)print(type(x)) #注意，元组中只有一个元素时，必须加逗号y = (1)print(type(y)) #不加括号的元组x = 1,2,3,&#x27;hello&#x27;print(x)\n\n()\n(2, 3, 4)\n(1,)\n&lt;class &#39;tuple&#39;&gt;\n&lt;class &#39;int&#39;&gt;\n(1, 2, 3, &#39;hello&#39;)\n\n2.2 创建元组x = tuple()print(x) #也得是可迭代对象a = tuple(range(10))print(a)\n\n()\n(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)\n\n由于元组不可变，所以只能删除整个变量，不能对其中元素操作。\n#元组切片x = (1,2,3,4)print(x[1:7]) #元组解包x = (1,2,3,4)a,b,c,d = xprint(a,b,c,d) #常用于结构赋值a,b = (1,2)print(a,b)\n\n(2, 3, 4)\n1 2 3 4\n1 2\n\n2.4 元组运算元组虽不可变，但其可以进行叠加，原元组不变，可合并为一个新元组。\n#加法a = (1,2)b = (3,4)c = a + bprint(c) #乘法a = (1,2)b = a * 3print(b)\n\n(1, 2, 3, 4)\n(1, 2, 1, 2, 1, 2)\n\n2.5 元组常用API参考列表操作，包括index（）也一样，只有最后的转列表为元组有区别，方法为tuple()。\n#count方法,列表与元组皆有a = (1,2,3)b = [1,1,2]print(a.count(1))print(b.count(1))\n\n1\n2\n\n三.字典3.1 字典简介\n字典是可变容器{}  \n字典的数据是无序的  \n字典由键值对构成，键实际就相当于下标\n\n3.2 字典创建#数字也可以作为键a = &#123;1:2,2:3&#125;print(a)print(type(a)) #也可以嵌套字典a = &#123;1:2,2:&#123;1:2,2:3&#125;&#125;print(a) #变量可以作为键x = &#x27;hello&#x27;y = 1a = &#123;x:1,y:2&#125;print(a) #重复的键会以最后一个键值对为准a = &#123;1:2,1:3&#125;print(a) #dict函数，等号前为键，后为值a = dict(a=1,b=2,c=3)print(a) b = dict([[1,2],[3,4]])print(b) c = dict([[1,2]])print(c)\n\n&#123;1: 2, 2: 3&#125;\n&lt;class &#39;dict&#39;&gt;\n&#123;1: 2, 2: &#123;1: 2, 2: 3&#125;&#125;\n&#123;&#39;hello&#39;: 1, 1: 2&#125;\n&#123;1: 3&#125;\n&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\n&#123;1: 2, 3: 4&#125;\n&#123;1: 2&#125;\n\n注意：使用dict（）时需要括号内的数据成对出现，因为要组成键值对。\n3.3 字典基本操作\nin 与not in用来表示一个键是否在字典中  \n可以向列表、元组一样通过”键”下标来访问字典中的值\n\n3.4 字典常用API# 查看字典长度,即键值对个数a = &#123;&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;print(len(a)) # str()把字典[字面量]变为字符串,网络传输常把这种字符串（json）传输a = &#123;&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;print(str(a),type(str(a))) # 清空字典a = &#123;&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;a.clear()print(a) #浅复制a = &#123;&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;b = a.copy()print(b) #访问键值对 get(key,x),x为找不到键时的返回值，默认为Nonea = &#123;&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;print(a.get(&#x27;name&#x27;))print(a.get(&#x27;address&#x27;,&#x27;not found&#x27;)) # 以列表返回一个视图(可迭代)对象，即一个一个打包的键值对 items()a = &#123;&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;print(a.items(),type(a.items())) # 返回一个键的迭代器 keys()a = &#123;&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;print(a.keys(),type(a.keys())) # 返回一个值的迭代器 values()a = &#123;&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;print(a.values(),type(a.values())) # 更新整个字典 update()，类似append和extenda = &#123;&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;b = &#123;&#x27;address&#x27;:&#x27;beijing&#x27;,&#x27;phone&#x27;:&#x27;123456789&#x27;&#125;a.update(b)print(a) # 删除字典中的键值对 pop(key,x),x为找不到键时的返回值，默认为Nonea = &#123;&#x27;name&#x27;:&#x27;zhangsan&#x27;,&#x27;age&#x27;:18,&#x27;sex&#x27;:&#x27;male&#x27;&#125;print(a.pop(&#x27;name&#x27;))print(a.pop(&#x27;address&#x27;,&#x27;not found&#x27;))\n\n3\n&#123;&#39;name&#39;: &#39;zhangsan&#39;, &#39;age&#39;: 18, &#39;sex&#39;: &#39;male&#39;&#125; &lt;class &#39;str&#39;&gt;\n&#123;&#125;\n&#123;&#39;name&#39;: &#39;zhangsan&#39;, &#39;age&#39;: 18, &#39;sex&#39;: &#39;male&#39;&#125;\nzhangsan\nnot found\ndict_items([(&#39;name&#39;, &#39;zhangsan&#39;), (&#39;age&#39;, 18), (&#39;sex&#39;, &#39;male&#39;)]) &lt;class &#39;dict_items&#39;&gt;\ndict_keys([&#39;name&#39;, &#39;age&#39;, &#39;sex&#39;]) &lt;class &#39;dict_keys&#39;&gt;\ndict_values([&#39;zhangsan&#39;, 18, &#39;male&#39;]) &lt;class &#39;dict_values&#39;&gt;\n&#123;&#39;name&#39;: &#39;zhangsan&#39;, &#39;age&#39;: 18, &#39;sex&#39;: &#39;male&#39;, &#39;address&#39;: &#39;beijing&#39;, &#39;phone&#39;: &#39;123456789&#39;&#125;\nzhangsan\nnot found\n\n四.集合4.1 集合基本介绍集合分set和固定集合frozenset\nset的元素值必须是不可变的，不能存储 list、dict 等可变类型。\n\n集合是可变的容器，固定集合是不可变的集合  \n集合内的数据绝对不同\n\n4.2 集合创建#set()创建a = set([1,2,3,4,5])print(a,type(a)) #空集合 注意：空集合创建必须用set()，不能用&#123;&#125;a = set()b = &#123;&#125;print(a,type(a))print(b,type(b)) #与列表的联合应用,set()是允许里面是列表的a = [1,2,3,4,5,6,1,2,2,3]b = set(a)print(b)\n\n&#123;1, 2, 3, 4, 5&#125; &lt;class &#39;set&#39;&gt;\nset() &lt;class &#39;set&#39;&gt;\n&#123;&#125; &lt;class &#39;dict&#39;&gt;\n&#123;1, 2, 3, 4, 5, 6&#125;\n\n来三个容易绕住你的问题 &gt;V&lt;\n# a里有几个数据a = &#123;(10,20,30),(20,10,30)&#125;print(a) # a中数据是什么a = &#123;(10),(10)&#125;print(a) # a中数据该怎么写a = &#123;(10,),(10,)&#125;print(a)\n&#123;(20, 10, 30), (10, 20, 30)&#125;\n&#123;10&#125;\n&#123;(10,)&#125;\n\n总结：一定要把基础学牢，前面的东西要学会\n4.3 集合操作#添加元素a = &#123;1,2,3&#125;a.add(4)print(a) #update()添加多个元素,实际为添加容器,不管是列表还是元组都会被取出数据传入a = &#123;1,2,3&#125;a.update([4,5,6],(7,8,9))print(a) #remove()删除元素，如果元素不存在，会报错a = &#123;1,2,3&#125;a.remove(1)print(a)     #discard()删除元素，如果元素不存在，不会报错a = &#123;1,2,3&#125;a.discard(4)print(a) &#x27;&#x27;&#x27;pop()对集合某种排序（有但不清楚，所以其实是固定排序），删除第一个元素并显示，如果集合为空，会报错方便记的,pop()就是随机删除一个元素并显示&#x27;&#x27;&#x27;a = &#123;1,2,3&#125;b = a.pop()print(a)print(b)\n\n&#123;1, 2, 3, 4&#125;\n&#123;1, 2, 3, 4, 5, 6, 7, 8, 9&#125;\n&#123;2, 3&#125;\n&#123;1, 2, 3&#125;\n&#123;2, 3&#125;\n1\n\n注:尽管集合无序，但可以用for循环来遍历集合\n4.4 判断集合是否含某元素a = &#123;1,2,3&#125;print(2 in a) b = &#123;1,2,3,4,5&#125;print(3 not in b)\n\nTrue\nFalse\n\n4.5 集合常用API# 添加元素 a = &#123;1,2,3&#125;a.add(4)print(a) # 清空集合 a = &#123;1,2,3&#125;a.clear()print(a) # 拷贝 a = &#123;1,2,3&#125;b = a.copy()print(b) # 返回差集 a = &#123;1,2,3&#125;b = &#123;2,3,4&#125; print(a.difference(b))print(a)  # 返回差集并删除该集合其他元素 a = &#123;1,2,3&#125;b = &#123;2,3,4&#125;a.difference_update(b)print(a)print(b)  # 返回交集 a = &#123;1,2,3&#125;b = &#123;2,3,4&#125;print(a.intersection(b)) # 返回交集并删除该集合其他元素a = &#123;1,2,3&#125;b = &#123;2,3,4&#125;a.intersection_update(b)print(a)print(b) # 判断两个集合是否完全不同 a = &#123;1,2,3&#125;b = &#123;2,3,4&#125;print(a.isdisjoint(b)) # 判断前集合是否为后集合子集 a = &#123;1,2,3&#125;b = &#123;2,3&#125;print(a.issubset(b)) # 判断后集合是否为前集合子集 a = &#123;1,2,3&#125;b = &#123;2,3&#125;print(a.issuperset(b)) # 返回俩集合不重复的元素，I为并集，即 U-Ia = &#123;1,2,3&#125;b = &#123;2,3,4&#125;print(a.symmetric_difference(b))print(a) # 返回俩集合不重复的元素，删除其他元素a = &#123;1,2,3&#125;b = &#123;2,3,4&#125;a.symmetric_difference_update(b)print(a) # 返回俩集合的并集a = &#123;1,2,3&#125;b = &#123;2,3,4&#125;print(a.union(b)) # 看集合长度a = &#123;1,2,3&#125;print(len(a))\n\n&#123;1, 2, 3, 4&#125;\nset()\n&#123;1, 2, 3&#125;\n&#123;1&#125;\n&#123;1, 2, 3&#125;\n&#123;1&#125;\n&#123;2, 3, 4&#125;\n&#123;2, 3&#125;\n&#123;2, 3&#125;\n&#123;2, 3, 4&#125;\nFalse\nFalse\nTrue\n&#123;1, 4&#125;\n&#123;1, 2, 3&#125;\n&#123;1, 4&#125;\n&#123;1, 2, 3, 4&#125;\n3\n\n","categories":["培训"],"tags":["python基础"]},{"title":"python语句基础","url":"/post/d47c321/","content":"\n语句是计算机执行程序的最小单位，标准语句写完后以分号结尾，相当于语言的句号，但python不需要。\n\n语句又分空语句、单语句、多行语句，python中空语句容易导致程序语义不明，所以python中空语句用pass 表示。\n\n\n一.单语句#简单的赋值语句a = 10 #简单的调用语句print(a) #range函数的调用循环语句range(10)\n\n二.空语句# pass表示你这里还是写了东西的，只是为空语句if a &gt; 10 :    pass\n\n三.多行语句多行语句较为完整，由于是多行所以需要缩进（Tab或4个空格），比如\n\n条件语句 if elif&#x2F;else  \n\n循环语句 for&#x2F;while\n\n\n3.1 条件语句if True:    print(&#x27;True&#x27;)elif True:    print(&#x27;111&#x27;)else:    print(&#x27;False&#x27;)\n\nTrue\n\n3.2 循环语句就是重复执行一些代码，直到满足条件为止。\n# 例如for是把可迭代对象中元素遍历完就结束a = [1,2,3,4,5]for i in a:    print(i)\n\nfor循环中有个值得注意的叫推导式（在之前的表达式中也提过），多用于新建可迭代对象\n#这就是列表推导式x = [1,2,3,4]y = [el**2 for el in x] print(y) # 字典推导式x = [65,66,67,68]y = &#123;chr(el):el for el in x&#125;print(y) a = &#123;&#x27;a&#x27;:1,&#x27;b&#x27;:2,&#x27;c&#x27;:3&#125;b = &#123;k:v for k,v in a.items()&#125;print(b) # 拓展，x = [表达式 for x in 可迭代对象 if 条件]x = [1,2,3,4]y = [el or 100 for el in x if el &gt; 2]print(y)\n\n[1, 4, 9, 16]\n&#123;&#39;A&#39;: 65, &#39;B&#39;: 66, &#39;C&#39;: 67, &#39;D&#39;: 68&#125;\n&#123;&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3&#125;\n[3, 4]\n\n# while 是只要条件满足（表达式为真）就一直循环,有个坏处，容易陷入死循环while False: #如果这里是True，就会一直打印hello world    print(&quot;hello world&quot;) else:    print(&quot;gg&quot;) # while正常用法a = 0while a &lt; 10:    print(a)    a += 1\n\ngg\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n# 特殊的range函数,括号内为左闭右开，默认左边为0,生成range类数据，一个可迭代容器# range(start,end,step),step为取的步长，默认为1，也可以反正取x = range(0,10)print(x,type(x)) for i in x:    print(i)\n\nrange(0, 10) &lt;class &#39;range&#39;&gt;\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n\n\n关键字\n\n&emsp;&emsp;break 会打断所在的循环，跳出循环，继续执行下一行代码  \n&emsp;&emsp;continue 会跳过这次循环，继续下一次循环  \n&emsp;&emsp;pass 表示也不做,整个过程不变\n# breaka = [1,2,3]for i in a:    if i == 2:        break    print(i) # continuefor i in a:    if i == 2:        continue    print(i) # pass,程序不会报错for i in a:    if i == 2:        pass\n\n1\n1\n3\n\n四.函数定义语句用于定义一个函数，包含 def 关键字：\ndef greet(name):    print(f&quot;Hello, &#123;name&#125;!&quot;)\n\n五.异常处理语句用于捕获和处理可能出现的错误。通过 try、except、else 和 finally 来定义异常处理流程。\ntry:    result = 10 / 0  # 触发异常except ZeroDivisionError:    print(&quot;除数不能为零&quot;)else:    print(&quot;没有错误&quot;)finally:    print(&quot;无论如何都会执行&quot;)\n\n除数不能为零\n无论如何都会执行\n\n六.导入语句用于导入模块或包，使得程序可以使用外部代码和库。\nimport math  # 导入math模块\n\n七.注释语句# 这是一个单行注释x = 5  # 这是一个行尾注释 &quot;&quot;&quot;这是一个多行注释可以用于更长的解释&quot;&quot;&quot;\n\n八.类定义语句用于定义一个类，类中包含属性和方法。\nclass Person:    def __init__(self, name, age):        self.name = name        self.age = age        def greet(self):        print(f&quot;Hello, my name is &#123;self.name&#125; and I am &#123;self.age&#125; years old.&quot;)\n\n九.with语句用于处理资源管理（如文件操作），确保资源在使用后被正确关闭或释放。\n# open函数,第一个参数为文件名，第二个参数为打开文件的方式f = open(&#x27;./1.txt&#x27;,&#x27;r&#x27;)print(f)for i in f:    print(i) # with语句，指在当前语境下作用，使用后自动解除文件占用，方便对文件进行增删查改with open(&#x27;./1.txt&#x27;,&#x27;r&#x27;) as f:    print(f)    for p in f:        print(p)\n\n&lt;_io.TextIOWrapper name=&#39;./1.txt&#39; mode=&#39;r&#39; encoding=&#39;utf-8&#39;&gt; 12345 123 &lt;_io.TextIOWrapper name=&#39;./1.txt&#39; mode=&#39;r&#39; encoding=&#39;utf-8&#39;&gt;\n12345 123\n\n","categories":["培训"],"tags":["python基础"]},{"title":"可变与不可变数据","url":"/post/4e2ae685/","content":"一.两者区别\n可变类型修改内容时，不会改变地址；\n\n不可变类型改值时，Python会创建一个新的对象，地址改变。\n\n\n# 可变类型a = [1,2,3]print(id(a))a.append(4)print(id(a)) #不可变类型a = 1print(id(a))a = a + 1print(id(a))\n\n2711527596416\n2711527596416\n140732630124984\n140732630125016\n\n二.判断数据类型#判断是否属于指定类型a = 1print(isinstance(a, dict))  #判断是否属于多个类型之一str1 = &#x27;abc&#x27;print(isinstance(str1, (int, str))) \n\nFalse\nTrue\n\n注：还有一个特别的判断\n# 判断空值a = Noneprint(isinstance(a, NoneType)) a = Noneprint(isinstance(a, None))\n\n---------------------------------------------------------------------------\nNameError                                 Traceback (most recent call last)\nCell In[97], line 3\n    1 # 判断空值\n    2 a = None\n----&gt; 3 print(isinstance(a, NoneType))\n    5 a = None\n    6 print(isinstance(a, None))\n\nNameError: name &#39;NoneType&#39; is not defined\n\n这里写一起因为两个测试之后其实是都不行的，需要注意。\n三.类型转换API# 将数字转化为对应字符a = 97b = chr(a)print(b) # 将字符转化为数字a = &#x27;A&#x27;b = ord(a)print(b) # 用Python表达式运行并返回结果a = eval(&#x27;2+3*4&#x27;)print(a) # 这里常常和.join()结合使用a = [&quot;1&quot;,&quot;2&quot;]b = &quot;+&quot;.join(a)print(b)print(eval(b))\n\na\n65\n14\n1+2\n3\n\n各种数据类型的转换就不赘述了，去找每个数据的创键过程复习。还有就是，像字符串转整数是会报错的，需要注意。\n","categories":["培训"],"tags":["python基础"]},{"title":"python基础变量（字符串、数字）","url":"/post/40fa0d1d/","content":"一.字符串常用方法下面是一些基本的字符串操作函数(简称字串串的常用API)，用于日常工作：\n#把字符串转为小写lower() str = &quot;Clocky&quot;str_proves = str.lower()print(str_proves) #把字符串转为大写upper() str = &quot;Clocky&quot;str_proves = str.upper()print(str_proves) #把字符串首字母转为大写()capitalize()str = &quot;clocky is a good man&quot;str_proves = str.capitalize()print(str_proves) #把字符串每个子字符串首字母转为大写title()str = &quot;clocky&quot;str_proves = str.title()print(str_proves) #移除字符串两端空白strip(),其中在其前加left、right可以只删除一端空白str = &quot;  clocky  &quot;str_proves = str.strip()print(str_proves) #将字符串拆分为列表,split(&quot;其中可选择分隔符，默认空格&quot;)str = &quot;clocky is?a good man&quot;str_proves = str.split(&quot;?&quot;)print(str_proves) #其中[]表示其中截取哪个位置开始的字符串。同时几个分隔符可以一起用str = &quot;clocky is?a good&amp; man&quot;str_proves = str.split(&quot;?&quot;)[1].split(&quot;&amp;&quot;)print(str_proves) #将列表中两个字符串连接为一个字符串join()str = [&quot;Clocky&quot;,&quot;is a good man&quot;]str_proves = &quot; &quot;.join(str)print(str_proves) #将字符串中字符串替换为另一个字符串replace()str = &quot;clocky is a good man&quot;str_proves = str.replace(&quot;clocky&quot;,&quot;Miko&quot;)print(str_proves) #查找字符串，返回第一次出现的位置find()，如果没找到返回-1str = &quot;clocky is a good man&quot;str_proves = str.find(&quot;a&quot;)print(str_proves) #检查字符串是否以某个字符串开头startswith()str = &quot;clocky is a good man&quot;str_proves = str.startswith(&quot;clocky&quot;)print(str_proves) #检查字符串是否以某个字符串结尾endwith()str = &quot;clocky is a good man&quot;str_proves = str.endswith(&quot;man&quot;)print(str_proves) #检查字符串是否只有数字字符isdigit()str = &quot;clocky7&quot;str1 = &quot;7&quot;print(str.isdigit())print(str1.isdigit()) #检查字符串是否只有字母字符isalpha()str = &quot;clocky7&quot;str1 = &quot;c&quot;print(str.isalpha())print(str1.isalpha()) #检查字符串是否只有字母和数字字符isalnum()str = &quot;clocky7&quot;str1 = &quot;c&quot;print(str.isalnum())print(str1.isalnum()) #检查字符串中某个字符串出现次数count()str = &quot;clocky is a good man，whom is a student&quot;str_proves = str.count(&quot;is&quot;)print(str_proves) #老式字符串格式化format()str = &quot;clocky is &#123;&#125; good man，whom &#123;&#125; a student&quot;num = &quot;a&quot;xiyu = &quot;is&quot;str_proves = str.format(num,xiyu)print(str_proves)   \n\n结果：\nclocky\nCLOCKY\nClocky is a good man\nClocky\nclocky\n[&#39;clocky is&#39;, &#39;a good man&#39;]\n[&#39;a good&#39;, &#39; man&#39;]\nClocky is a good man\nMiko is a good man\n10\nTrue\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\nTrue\n2\nclocky is a good man，whom is a student\n\n二.数字变量2.1 进制十进制直接表示；二进制0b表示；八进制0o表示；十六进制0x表示。\n#注：其中10为测试数字,根据各种进制转换为十进制数 #十进制num = 10print(num) #八进制num = 0o10print(num) #十六进制num = 0x10print(num) #二进制num = 0b10print(num)\n\n结果：\n108162\n总结：&emsp;&emsp;也就是说是多少进制就是一轮有多少个数，例如10进制09共10个数，八进制07共8个数，一轮所有数走完后就进1.\n2.2 浮点数实际上浮点数有多种不同的表示方法，最复杂的科学计数法是”假设Xe+y,X为原数，e+y则表示10的y次方，原式的结果就是将两者相乘”。下面就是具体的例子：\n#不同的表示方法 num = 10.print(num) num1 = 10.0print(num1) num2 = .9print(num2) #科学计数法num3 = 1.52e-3print(num3)\n\n结果：\n10.0  \n10.0  \n0.9  \n0.00152\n\n2.3 布尔类型· 布尔只有两个值：True、False\n· 而数字中除了0其余皆为True\n· 还有个需要注意的地方，空字符串为False，但空格字符串为True\n· 用bool（）将其转化为布尔值\nprint(bool(1))print(bool(0))\n\n结果：\nTrue  \nFalse\n\n2.4 数字类型转换·bin()是将数字转换为二进制·oct()是将数字转换为八进制·hex()是将数字转换为十六进制·float()是将数字转换为浮点数·complex()是将数字转换为复数·int()是将数字转换为整数\n#二进制 num = 6print(bin(num)) #八进制 num = 6print(oct(num)) #十六进制num = 6print(hex(num)) #浮点数num = 6print(float(num)) #复数num = 6print(complex(num)) #合成复数，将前一个作为实部，后一个作为虚部num = 6num1 = 2print(complex(num, num1)) #十进制整数,只保留整数num = 6.9print(int(num))\n结果：\n0b110  \n0o6  \n0x6  \n6.0  \n(6+0j)  \n(6+2j)  \n6\n\n2.5 四舍六入，五看齐，奇变偶不变（规则）这里的意思是，在这种规则下，小数点后面的数，如果小于5，则舍弃，如果大于5，则进位。  \n如果等于5，那么看整数是奇是偶：\n是奇数则进位；  \n是偶数则舍弃。\n三.字节串字节串通过在字符串前加上 $b$ 来表示，其整个数据类型为bytes。\na = b&quot;hello&quot;print(a)print(type(a))\n\n结果：\nb&#39;hello&#39;  \n&lt;class &#39;bytes&#39;&gt;\n\n四.空值空值为None，其类型为NoneType(注：print（）本体也为空值)。举个简单的例子：\na = Noneprint(a)print(type(a)) b = print()print(b)\n\n结果：\nNone  \n&lt;class &#39;NoneType&#39;&gt;  \nNone\n\n","categories":["培训"],"tags":["python基础"]},{"title":"python运算符以及表达式基础","url":"/post/fbe2c3eb/","content":"一.运算符1.1 算术运算符基本有的加（+），减（-），乘（*）。除（&#x2F;）会将结果转换为小数，介绍一下其他的方法：\n# 取模运算，就是求余数%a = 10b = 3print(a % b) # 幂运算，就是次方a = 2b = 3print(a ** b) # 整除//a = 10b = 3print(a // b)\n\n1\n8\n3\n\n1.2 比较运算符高级一点的就是 &lt;&#x3D;,&gt;&#x3D;,!&#x3D;,简单一点的,&#x3D;&#x3D;,&lt;,&gt;。\n1.3 逻辑运算符（难）# A and B,需两表达式都为True才为True（若A为False，则B不执行,目的是节约算力）x = 5y = 10re = x &gt; 3 and y &lt; 20print(re) # 难点,A为True时，表达式结果就是B的结果# 前A为False时，表达式结果就是A的结果x = 5y = 10re = x and yprint(re) a = 0b = 5re = a and bprint(re) # A or B,需两表达式都为False才为False（若A为False，则B不执行,目的是节约算力）x = 5y = 10re = x &lt; 3 or y &lt; 20print(re) # 难点,A为False时，表达式结果就是B的结果# 前A为True时，表达式结果就是A的结果a = 0b = 5re = a or bprint(re) A = 5B = 0re1 = A or Bprint(re1) # not 非运算,即判断表达式是否为Falsex = 5re = not xprint(re) re1 = not x &gt; 3print(re1) re2 = not Falseprint(re2)\n\nTrue\n10\n0\nTrue\n5\n5\nFalse\nFalse\nTrue\n\n补充：a&lt; x &lt; y 可以看成是a&lt; x and x &lt; y\n# python中这一条语句是同时执行的，表示100 &lt; 10 and 10 &lt; 30，所以是Falsex = 10re = 100 &lt; x &lt; 30print(re) &#x27;&#x27;&#x27;但其他的编程语言会先执行100 &lt; x 然后判断(100 &lt; x) &lt; 30100 &lt; x 结果为0(False),而 0 &lt; 30 结果为1(True),所以其他编程语言会返回True&#x27;&#x27;&#x27;\n\nFalse\n\n1.4 赋值运算符&emsp;&emsp;最简单的是 &#x3D; ，其后所有算术运算符都可以写成+&#x3D;，*&#x3D;这种形式。&#x3D; 是一种赋值运算符，先执行右边的表达式，再把结果赋值给左边的变量。\n注：a++和a–这类运算在python中是不合法的\n1.5 位运算符主要应用于二进制，若是其他整数则转换为二进制，然后进行计算，默认返回整数值。\n# 按位与&amp;，如果a和b的相应位都是1，则结果位为1，否则为0a = 0b1010b = 0b0101print(a &amp; b) # 按位或|，只要a和b中至少有一位是1，则结果位为1，否则为0a = 0b1010b = 0b0101print(a | b) # 按位异或^，如果a和b的相应位不同，则结果位为1，否则为0a = 0b1010b = 0b0100print(a ^ b)  # 按位取反，其实就是二进制转换为十进制，然后取负号，再减一a = 0b1010print(~a) # 左移&lt;&lt;，将a转换为二进制整体向左移动，右移同理（右边超出的部分丢弃）a = 10print(a &lt;&lt; 2)\n\n0\n15\n14\n-11\n40\n\n一个30年的笔试题\n#如何才能使得print(x.y)为20，10&#x27;x = 10y = 20&#x27;&#x27;&#x27;python里可以用x,y = y, x结构赋值其他语言不行,这里简单的可以使用Temp变量即c = aa = bb = c&#x27;&#x27;&#x27;#讲到这里也可以使用异或x = x ^ yy = x ^ yx = x ^ yprint(x,y) \n\n具体为什么能行呢，可以自己在草稿纸上演算一下两个数的异或，再用异或后的值再与其中一个异或一次，就会得到另一个了。\n1.6 身份运算符is，is not 其要求是不是同一个对象，而 &#x3D;&#x3D; 判断是不是同一个数值。\na = [1, 2, 3]b = [1, 2, 3]print(a == b) #True, 比较的是值print(a is b) #False,比较的是内存地址\n\nTrue\nFalse\n\n1.7 成员运算符就是in 和 not in。\n1.8 三目运算符# 就是if else用在表达式里a = 1b = 2 max = a if a&gt;b else bprint(max)#如果 a&gt;b 成立，就把 a 作为整个表达式的值，并赋给变量 max；#如果 a&gt; b 不成立，就把 b 作为整个表达式的值，并赋给变量 max。\n\n\n更多的时候，我们借助()来明确优先级问题\n\n二.表达式就是一行代码（最小单位），是一个数值都行，多行表达式组成语句，多条语句组成代码块，然后就是程序。\n举几个简单的表达式：\n# 算术表达式a = 5b = 3result = a + b  # 加法result = a / b  # 除法# 赋值表达式a = 5  b = a + 3  # 计算并赋值 # 有一种属于python的海象运算符，同时取值与赋值if (a := 5) &gt; 0:  # 赋值表达式    print(a)# 推导式a = [1, 2, 3, 4]result = [x * 2 for x in a]  # 创建一个新列表，元素是原列表每个元素的两倍","categories":["培训"],"tags":["python基础"]},{"title":"大学开始的第一次培训课程","url":"/post/148b0ced/","content":"环境的配置conda的安装&emsp;&emsp;敲代码的都知道学计算机都要会装环境，往前从来都是班级的大佬带着安装，这次尝试着自己安装。\n&emsp;&emsp;Anaconda直接在其官方链接Anaconda上下载即可，安装完成后如下图：\n\n配置环境变量&emsp;&emsp;Anaconda安装完成后，先找到其安装路径，如下图流程：\n\n\n&emsp;&emsp;随后往上滑找到condabin文件夹，进行下面的操作：\n  \n&emsp;&emsp;随后进入电脑的高级系统设置(在桌面右击”我的电脑”并点击”属性”即可)&emsp;&emsp;在”高级系统设置”中点击”环境变量”，在”系统变量”中找到Path，点击新建，随后将找到的condabin文件夹路径粘贴进去，如下图：\n\n简单的conda命令使用&emsp;&emsp;一.首先进行conda的激活，在电脑任意文件夹路径栏里键入cmd进入终端界面，输入conda activate，如果出现如下图所示，则表示conda已经激活成功。\n\n&emsp;&emsp;二.键入conda help可以查看conda的基本命令，此处采用 “conda create -n 你命的环境名 python&#x3D;&#x3D;你要下的版本” 创建一个虚拟环境。\n\n&emsp;&emsp;三.输入conda env list查看已创建环境的位置。\n使用代码编辑器配置环境（vscode为例）\npython基础关于注释&emsp;&emsp;在python中，使用#表示单行注释，使用’’’表示多行注释。因为很多时候注释较长，使用’’’可以换行来写，方便编写时审阅。\n&#x27;&#x27;&#x27;nnnnihao666&#x27;&#x27;&#x27;\n\n关于输入输出&emsp;&emsp;在python中，使用print()函数来输出内容，使用input()函数来输入内容。其中输出有两个重要的内容，一个是sep，一个是end.\n&emsp;&emsp;·sep 参数用来定义数据之间的分割符，默认为空格\n&emsp;&emsp;·end 参数用来定义数据输出完后用什么字符结束，默认是换行符(‘\\n’)\n&emsp;&emsp;下面是关于两个参数的测试代码：\n# 这是输出方面的测试代码print(123, 132, 213,sep=&#x27; &#x27;, end=&#x27;\\n&#x27;)print(&quot;hello world!&quot;)print(&quot;我们班有多少人&quot;, 12)print(1, 2, 3, 4)print(1, 2, 3, 4, sep=&quot; &quot;, end=&quot;\\n&quot;)print(1, 2, 3, 4, sep=&quot;-&quot;, end=&quot;hello&quot;)print(345)# 这是输入方面的测试代码x = input(&quot;请输入任意一个数据&quot;)print(x)\n&emsp;&emsp;结果一测便知，实践永远是验证的最好方式。\n基础变量变量命名&emsp;&emsp;1.变量默认只能由包含数字、字母、下划线的字段命名&emsp;&emsp;（unicode可编码的字符都可命名，包括中文汉字）&emsp;&emsp;2.数字不能作为变量名的开头&emsp;&emsp;3.变量名不能是python官方设置的保留字（如and、or、if、while等）&emsp;&emsp;4.大写字母约定通常表示常量，即基本不变的数据\n(约定及大家都默认使用的方式，即使可以用其他的)\n赋值与取值1.两个变量不能进行同时赋值与取值\n  \n&emsp;&emsp;将其分别赋值则可以完成，原因是其中逗号不为逗号运算符，逗号运算符讲究先后顺序\n2.在这里有一个我认为比较难懂的地方，就是\n· a,b,c&#x3D;x1,x2,x3\n&emsp;&emsp;这个大过程是合适的，且同时进行。我的理解是若默认x1，x2，x3都有其值，等号右侧的式子会先进行x1，x2，x3的取值（同时），然后等号两侧均转换为元组，再按顺序由{角标02及x1x3}赋值给a，b，c。因此整个大过程是同时的。  \nx1 = 10x2 = 20x3 = 30b = 40a,b,c = x1,x2,bprint(a,b,c)\n\n&emsp;&emsp;最后的结果是 10 20 40，上面的代码则证明这一点，x1，x2，b会先进行同时取值，然后再依次赋值给a，b，c，所以最后b的值是20，c的值是40而非同时b的值20。\n字符串(1)空格和“空”也能是字符串  \n(2)r’c:\\Software\\code\\py\\hqyj\\n\\t\\3.8_2.ipynb’（开头的r表示里面所有的\\n,\\t之类的全是文字，不转义）  \n(3)”\\\\“ 表示反斜杠\n&emsp;&emsp;示例：\nprint(&quot;nihao\\t wode&quot;)print(&quot;nihao\\\\t wode&quot;)\n\n&emsp;&emsp;输出结果是：\nnihao    wode\nnihao\\t wode\n\n字符串合并&emsp;&emsp;两个字符串可以通过加号相连，同时如果两个字符串紧靠在一起也会自动合并，最后结果都是小米13。\n# 加号合并a = &#x27;小米&#x27;b = &#x27;13&#x27;print(a + b)# 紧靠合并c = &#x27;小米&#x27;&#x27;13&#x27;print(c)\n\n&emsp;&emsp;一个字符串可以用*乘数字来进行累乘，效果就是叠加三次的”小米”。\n# 乘号叠加a = &quot;小米&quot;d = a * 3print(d)\n\n切片&emsp;&emsp;可以通过下标找到一个字符串中固定位置的字符，也可以通过范围切片寻找一段字符串。\n# 切片或下标,其中为左闭右开e = &#x27;小米13pro&#x27;print(e[0])print(e[-2])print(e[-7:3])print(e[3:])# 切片加步长f = &#x27;明日方舟终末地&#x27; print(f[::2])   print(f[5:3:-1])\n\n&emsp;&emsp;结果是：\n小\nr\n小米1\n3pro\n明方终地\n末终\n\n注：这里还有一道经典笔试题\n# 经常笔试题g = input(&#x27;请输入一个字符串：&#x27;) print(g)print(g == g[::-1])\n\n&emsp;&emsp;这段代码可以判断输入的字符串是否是回文，依次类推可以实现其他更多类似回文的问题。\n判断子串&emsp;&emsp;用 a in b 即可知道a是否为b的字串，且返回布尔类型的值。\n字符串长度&emsp;&emsp;用 len()函数来获取。\n字符串格式化&emsp;&emsp;占位符可以有效格式化字符串，缺点是比较麻烦，下面是示例：\n# 占位符a = &#x27;我叫%s,今年%d岁&#x27;%(&#x27;clocky&#x27;,20)print(a)b = &#x27;一共%f元&#x27;%(100)# 保留两位小数c = &#x27;一共%.2f元&#x27;%(100)# 左对齐，占8位字符，保留3位小数d = &#x27;一共%8.3f元&#x27;%(100)print(b)print(c)print(d)# 科学计数法(1e+08就是1*10^8)e = &#x27;一共%g元&#x27;%(100000000)print(e)    \n\n&emsp;&emsp;结果是：\n我叫clocky,今年20岁\n一共100.000000元\n一共100.00元\n一共 100.000元\n一共1e+08元\n\n&emsp;&emsp;更好用的是f-string格式化，它以f开头，其中的表达式则用{}包起来，而且{}中可以用：进一步格式化，如{s:2f}就是把s的值保留两位小数。下面给个简单的例子：\n# 格式化字符串,f-stringa = 34b = 23c = 12print(f&quot;abc(&#123;a&#125;, &#123;b&#125;, &#123;c&#125;)&quot;)\n\n&emsp;&emsp;结果:\nabc(34, 23, 12)\n\n","categories":["培训"],"tags":["python基础"]},{"title":"回调与闭包函数基础","url":"/post/3fa5d443/","content":"一.回调函数&emsp;&emsp;把一个函数传入另一个函数，外面的函数叫工具函数，传入的函数就叫回调函数 (业务函数)，工具操作后得到的数据交给回调函数处理。实质上就是运行过程中回去调用之前的函数。\n# 工具函数def find_odd(x,fun):    for i in x:        if i % 2 == 1:            fun(i) # 回调函数1def fun(x):    print(x**2) #回调函数2def fun1(x):    a = []    a.append(x)    print(a) x = [1,2,3,4,5,6]re = find_odd(x,fun)re1 = find_odd(x,fun1)\n\n1\n9\n25\n[1]\n[3]\n[5]\n\n就像上面所写，回调函数会把处理过的数据拿来做各种操作，其实就是把拿来的数据完成各种业务。\n二.函数闭包函数内部有函数，内部函数即闭包函数，其作用是：\n\n把环境的值单独保存，不被其他地方的环境影响\n\n实质就是同名的变量名可以存在，但是需要用闭包来实现\n\n借用嵌套作用域，从里面的函数中访问到外面函数的变量，但更外面的环境访问不了，决定一个东西的版权。\n\n\n# 拿支付宝和美团举例def alipay():    money1 = 100     def tool(pwd,new_money):        nonlocal money1        if pwd == 123:            money1 = new_money        print(money1)    return tool    def meituan():    fn = alipay()    fn(2323,100000) #函数调用的时候是在全局还是alipay涵数内部去执行代码的？    fn(123,666666)    fn(555,77777) meituan()\n\n100\n666666\n666666\n\n&emsp;;&emsp;我们先来看alipay的函数，其内部定义了一个变量money1和一个工具tool函数。\ndef alipay():    money1 = 100     def tool(pwd,new_money):        nonlocal money1        if pwd == 123:            money1 = new_money        print(money1)    return tool\n\n&emsp;&emsp;这就是一个闭包，tool就是所谓的闭包函数，它将alipay里的数据单独保存无法直接被外界作用域访问。&emsp;&emsp;tool实际上就给了外界能够访问操作alipay数据的一个方法，且只能用它，必须满足它里面设定的条件。比如这里，tool函数里面设定了pwd（密码）必须是123，才让你修改其中的数据money1。这也就决定了这个’从alipay取钱’的版权是tool函数的，也就是设计alipay的程序工程师。\n&emsp;&emsp;再来看meituan的函数。\ndef meituan():    fn = alipay()    fn(2323,100000) #函数调用的时候是在全局还是alipay涵数内部去执行代码的？    fn(123,666666)    fn(555,77777) meituan()\n\n&emsp;&emsp;其中，meituan函数调用了alipay函数，但其无法直接访问修改里面的moeny1，所以第一次密码输错的时候，没有将moeny1的值修改为100000，而是只打印了100。第二次密码输对了，就将其更改为666666并保存。\n","categories":["培训"],"tags":["python基础"]},{"title":"如今到大三的一些感悟","url":"/post/1d35813b/","content":"\n&emsp;&emsp;从高中三年走到大学三年，不知不觉已经过去这么长一段时间了。感觉时间过的很快，从小学开始，下一个学习阶段都会变得更快，到了大学三年的时间只有小学一年的样子，很难想象小学的时候会过的那么充实。本人学习阶段横跨三省，因为父母工作的原因，小时候周转与河南、四川和浙江。浙江小学六年是记忆最深刻的日子，那时成绩不错，也是最快乐的时候。&emsp;&emsp;我还记得当年最流行的游戏，枪神纪、生死狙击、qq飞车，甚至玩到今天的Minecraft也是在那时候启蒙的。大城市的孩子，没有乡下孩子玩的那么纯真那么有意思，但小伙伴们都喜欢带我去废弃工地的池塘里夹螃蟹、捉蝌蚪，穿溜冰鞋，滑滑板，骑自行车，也一起约着绕城。我们那几个熟的都喜欢跑到别人家玩，家长们也都很开心。\n\n&emsp;&emsp;但人总会随着时间长大。\n&emsp;&emsp;从六年级下册来到四川后，这里改变了我很多。时间很紧，生活很急，老师盯着你，如果处理不当，学习也会压迫你。尽管最后修得成果，但已经没有从前的自由和天真。高中曾经谈过一场不合时宜的早恋，最后以不和而终。这一场梦给我的家庭带来了极大的影响，我的妈妈常常心疼我，我爸总说我已经做到了这个年纪不该承担的责任。总而言之，你不该看起来比父母更沧桑，爸妈永远站在你身后。\n\n&emsp;&emsp;关于我的父母，我很骄傲的告诉各位，他们是全天下最好的父母。\n&emsp;&emsp;他们自我出生起就没有对我动过粗，他们尽自己的努力用我能接受的方式来教育我。没有生活里的说教，不像社会上的很多父母，眼里似乎只有你的学习，和学校一起压垮一个孩子，口口声声都是为你好。我的父母一直让我们兄弟俩去做自己喜欢的事，无论是什么，只要想做，那就去做吧，享受一切。爸说，他们不能永远在你身边，人总会找到属于自己的人生，将来或许会走得很远，但”爸妈永远是你的后盾，你永远是爸妈的孩子，无论遇到什么事，我和你老妈都会努力，哈哈哈。”我从未感受到束缚，去做了很多我想做的事，也从不后悔。哪怕是当时那场早恋，留下过那么多遗憾，给我的家人带来那么多影响，他们只希望我能做自己，而我从中学会了很多为人处世的道理，也看清了很多事。\n&emsp;&emsp;得益于我所经历的一切，笔者认为每个人的人生都各有精彩。迄今为止发生的事，每一件都有其意义，它组成了现在的你，也会是你的未来。不是每个人都应该去做领导、做天才，大家都有自己喜欢的事，只要到最后你都尽力过，坦然接受自己，那么人生的这道坎也就过了。无论走向哪里，都无关紧要，世界很大，就是因为存在形形色色的人才会有绚烂的文明。  \n&emsp;&emsp;最后也希望我能完成自己的梦想：成为一束自由的光，能够在不经意间走进你的世界，为你的世界带来更多温暖与快乐。\n","categories":["日常"],"tags":["有感而发"]}]